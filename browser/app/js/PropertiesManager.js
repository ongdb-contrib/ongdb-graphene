'use strict';
/** @jsx h */
import {Component, h} from 'preact';

import CONST from './enums/CONST';
import PROPERTY_TYPES from './enums/PROPERTY_TYPES';
import Property from './do/Property';

/* example component to start from */
class PropertiesManager extends Component {
  constructor(props) {
    super(props);

    this.state = {
      selectedProperty: null,
      entity: props.entity
    };
  }

  componentWillReceiveProps(nextProps) {
    this.setState({
      entity: nextProps.entity,
      selectedProperty: null
    });
  }

  componentWillUpdate(props, state) {
    this.props.onEntityChange(state.entity);
  }

  selectProperty(prop) {
    this.setState({ selectedProperty: prop });
  }

  addProperty() {
    // 增加一个搜索框
    const entity = this.state.entity;
    entity.properties.push(new Property());
    this.setState({ entity });
  }

  changePropertyName(e, prop) {
    prop.key = e.target.value;
  }

  deleteProperty(prop) {
    const entity = this.state.entity;
    const selectedProperty = this.state.selectedProperty;
    entity.properties = entity.properties.filter((property) => property.id !== prop.id);

    if (selectedProperty && selectedProperty.id === prop.id) {
      this.setState({ selectedProperty: null });
    }

    this.setState({ entity });
  }

  render(props, state) {
    const entity = state.entity;
    const typesWithLimit = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.INT, PROPERTY_TYPES.FLOAT, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];
    const textTypes = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];

    if (!entity) {
      return <div className="no-selected">Select node/edge to edit properties</div>;
    }
    return <div id={CONST.PROPERTY_MENU_ID} className={CONST.PROPERTY_MENU_CLASS}>
      <div className="header">
        <span className="color">
          <input id="entity-color" value={entity.color} onInput={ this.linkState('entity.color')} type="color" />
        </span>
        <span className="label">
          <input id="entity-label" value={entity.label} onInput={ this.linkState('entity.label') }/>
          <small className="type">{entity.isNode && 'node' || entity.isEdge && 'edge'}</small>
        </span>
        <button className="add-button" onClick={ this.addProperty.bind(this) }>+ Add property</button>
      </div>
      <div className="main">
        <div id="properties-search">
          <p>
            <input type="text" name="" id="properties-search-input" placeholder="Search properties" onInput={ this.searchData.bind(this) } />
          </p>
          <ul id="properties-search-result" onClick={ this.searchResultClick() } />
        </div>
        <div className="properties">
          <ul id="properties-list">
            { entity.properties.map((prop) => <li className={{
              selected: (state.selectedProperty && prop.id === state.selectedProperty.id),
              disabled: prop.isSystem,
              schema_indexes: prop.key === 'schema-indexes'
            }}>
              <div className="property">
                <input
                    type="text"
                    className="propertyName"
                    value={prop.key}
                    onInput={ (e) => this.changePropertyName(e, prop) }
                    onClick={this.selectProperty.bind(this, prop)}
                    disabled={prop.isSystem}
                />
                <small className="type">{prop.type}{prop.isRequired ? '!' : ''}{prop.isAutoGenerated ? '@' : ''}</small>
                &nbsp;
              </div>
              <div className="remove-property-button" title="Delete" onClick={ this.deleteProperty.bind(this, prop) }>
                x
              </div>
            </li>)
            }
          </ul>
        </div>
        { state.selectedProperty &&
        <div className="property-edit" id="property-edit">
          <ul>
            <li>
              <label>
                <span>type:</span>
                <select value={ state.selectedProperty.type } onChange={ this.linkState('selectedProperty.type') }>
                  {
                    Object.keys(PROPERTY_TYPES).map((type) => <option
                        value={PROPERTY_TYPES[type]}>{PROPERTY_TYPES[type]}</option>)
                  }
                </select>
              </label>
            </li>
            { !state.selectedProperty.isAutoGenerated &&
            <li>
              <label>
                <span title="Property's default value">Default:</span>
                <input
                    className="defaultValue"
                    value={ state.selectedProperty.defaultValue }
                    onInput={ this.linkState('selectedProperty.defaultValue') }
                />
              </label>
            </li>
            }
            <li>
              <label>
                <span title="Is the property required">Required:</span>
                <input
                    className="isRequired"
                    type="checkbox"
                    checked={ state.selectedProperty.isRequired }
                    onClick={ this.linkState('selectedProperty.isRequired') }
                />
              </label>
            </li>
            <li>
              <label>
                <span title="Auto generated">Auto gen.:</span>
                <input
                    className="isRequired"
                    type="checkbox"
                    checked={ state.selectedProperty.isAutoGenerated }
                    onClick={ this.linkState('selectedProperty.isAutoGenerated') }
                />
              </label>
            </li>

            { (typesWithLimit.indexOf(state.selectedProperty.type) !== -1) &&
            <li>
              <label>
                <span>min{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' len.' : '' }:</span>
                <input
                    className="limitMin"
                    type="number"
                    min="0"
                    max="100000"
                    value={state.selectedProperty.limitMin}
                    onInput={ this.linkState('selectedProperty.limitMin') }
                />
              </label>
              <label>
                <span>max{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' len.' : '' }:</span>
                <input
                    className="limitMin"
                    type="number"
                    min="0"
                    max="100000"
                    value={state.selectedProperty.limitMax}
                    onInput={ this.linkState('selectedProperty.limitMax') }
                />
              </label>
            </li>
            }
          </ul>
          <div className="propertyDescription">
            <label>
              <span>Description:</span>
              <input
                  value={state.selectedProperty.description}
                  onInput={ this.linkState('selectedProperty.description') }
              />
            </label>
          </div>
        </div>
        }
      </div>
    </div>;
  }

  searchData() {
    $(function () {
      $('#properties-search-input').on('input', function () {
        search($(this).val());
      });
    });
  }

  searchResultClick() {
    const element = document.getElementById('properties-search-result');
    if (element !== null) {
      element.addEventListener('click', (e) => {
        const target = e.target;
        // document.querySelector('#properties-search-result .li').style.background = 'transparent';
        // document.getElementById(target.id).style.background = '#ccc';
        // addProperty();
        console.log(target.id);
      });
    }
  }
}

const localStorageItem = 'nma.grad3ph';
const localStorageItemSaves = 'nma.grad3ph.saves';
const searchList = searchData(JSON.parse(localStorage.getItem(localStorageItem)), JSON.parse(localStorage.getItem(localStorageItemSaves)));

/**
 * @param localStorageItem：当前数据
 * @param localStorageItemSaves：缓存的历史数据
 * @returns {string}
 * @private
 */
function searchData(localStorageItem, localStorageItemSaves) {
  localStorageItemSaves.push({ data: localStorageItem });
  const data = [];
  const mapDuplicate = {};
  for (const lst of localStorageItemSaves) {
    const nodes = lst.data.nodes;
    const edges = lst.data.edges;
    // 处理节点属性
    for (const mp of nodes) {
      const pros = mp.properties;
      for (const pr of pros) {
        const ele = {
          search: pr.key + pr.type + pr.defaultValue + pr.description,
          key: pr.key,
          type: pr.type,
          defaultValue: pr.defaultValue,
          limitMin: pr.limitMin,
          limitMax: pr.limitMax,
          isRequired: pr.isRequired,
          isAutoGenerated: pr.isAutoGenerated,
          description: pr.description
        };
        if (!mapDuplicate.hasOwnProperty(pr.key)) {
          data.push(ele);
          mapDuplicate[pr.key] = 1;
        }
      }
    }
  }
  return data;
}

/**
 * @param val:查找属性的输入框输入值
 * @returns {string}
 * @private
 */
function search(val) {
  // 获取ul
  const oul = document.getElementById('properties-search-result');
  // 定义新数组，保存符合搜索内容要求的数据
  const a = [];
  let k = 0;
    // 循环判断符合要求的数据
  for (let j = 0; j < searchList.length; j ++) {
    // 数据中不包含搜索内容值的返回-1
    if (searchList[j].search.indexOf(val) !== -1) {
      const mp = searchList[j];
      a[k++] = mp.key.concat('|', mp.type, mp.defaultValue, mp.description, '|');
    }
  }
  // 清空ul里面的内容
  document.getElementById('properties-search-result').innerHTML = '';
  // 循环将数据输出到ul下
  for (let p = 0; p < a.length; p ++) {
    // 创建li
    const oli = document.createElement('li');
    // 定义li里的内容
    oli.innerHTML = a[p];
    // 将li添加到ul里
    oul.appendChild(oli);

    // 添加点击事件
    oli.className = 'li';
    oli.id = 'properties-search-result-'.concat(p);

    if (p > 10) {
      break;
    }
  }
}

export default PropertiesManager;
